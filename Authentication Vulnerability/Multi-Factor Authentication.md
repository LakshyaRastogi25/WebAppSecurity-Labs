# What is Two-factor authentication?
**Two-factor authentication** (2FA) is based on something you know and something you have. This usually requires users to enter both a traditional password and a temporary verification code from an out-of-band physical device in their possession.

## What are **Authentication Tokens**?

**Authentication tokens** are digital or physical mechanisms used to prove a user's identity and grant them access to systems or applications. They are often used as part of MFA (e.g., the "something you have" factor).

Examples of Authentication Tokens are :-
 - One-Time password (OTP)
 - Json Web Token (JWT)
 - Physical Tokens (key fob)
----
## **LAB:1**

## **Lab: 2FA simple bypass**

**AIM**- This lab's two-factor authentication can be bypassed. To solve the lab, access Carlos's account page.

**Given Credentials**-

->**Your credentials:** 
```
wiener:peter
```
->**Victim's credentials** 
```
carlos:montoya
```

**Step 1:** Access the Lab and Login with Your Credentials
 - **Action:** Log in to the application using the provided credentials.
 - **Observation:** After a successful login, the application prompts you to enter a verification code that has been sent to your email.
 - **Submit:** Enter the correct verification code from your email to complete the login process.

**Step 2:** Log Out and Enter Victim Credentials
 - **Action:** Log out of your current session.
 - **Victim Login:** Enter the victim's credentials (provided in the lab).
 - **Observation:** After entering the credentials, you will be prompted to enter a verification code (just like in Step 1).

**Step 3:** Bypass the MFA
 - **Action:** To bypass the MFA, modify the URL by removing the "/login2" parameter.
 - You will notice that after doing so, the application will redirect you to the home page.
 - **Navigate:** Once on the home page, click on the "My Account" section on the left side of the page.

**Step 4:** Explanation of the Logic Flaw
 - **Analysis:** The application has a logic flaw that makes the MFA ineffective in certain scenarios. After submitting the victim’s credentials, the system logically authenticates the user, and the MFA becomes a redundant step.
 - **Conclusion:** The two-factor authentication (2FA) in this case is merely a weak barrier that has been misconfigured, allowing attackers to bypass it easily by manipulating the URL.

----
## **LAB:2**

## **Lab: 2FA simple bypass**

**AIM**- This lab's two-factor authentication is vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.

**Given Credentials**-
 - Your credentials: wiener:peter
 - Victim's username: carlos

**Step 1:** Access the Lab and Configure Burp Suite

 - Access the lab and configure Burp Suite as your proxy.

 - Ensure intercept is enabled.

 - Set up the browser to route traffic through Burp Suite.

Log in with the provided wiener credentials:
```
Username: wiener
Password: peter
```
Retrieve the verification code sent to the client email to simulate a valid MFA flow.

**Step 2:** Analyze the GET /login Request
 - Observe the GET /login request in Burp Suite.
 - Look for the verify parameter in the request.
 - Notice that the verify parameter is set to wiener.

**Step 3**: Analyze the POST /login2 Request
 - Submit the verification code as instructed by the lab.
 - Capture the POST /login2 request in Burp Suite and analyze its contents.
 - Parameters include:
  - **verify:** The username (e.g., wiener).
  - **session:** The session token.
  - **mfa-code:** The Multi-Factor Authentication code.

**Step 4**: Modify the verify Parameter
 - Send the GET /login request to Burp Repeater.
 - Change the verify parameter from wiener to carlos and send the request.
 - Copy the session token from the response (this token now corresponds to the carlos user).

**Step 5:** Launch a Brute-Force Attack on the MFA Code
 - Send the POST /login2 request to Burp Intruder.

**Set the following payload positions:**
 - Change the verify parameter to carlos.
 - Update the session token to the one retrieved in Step 4.
 - Add the mfa-code parameter to the payload.
 - Configure the attack:
 - Go to the Payloads tab.
 - Select Brute Force as the payload type.
 - Set the range of the payload:
```
Min: 0000

Max: 9999
```
 - Use only numerical characters (remove any alphabetic characters from the payload list).
 - Start the brute-force attack.

**Step 6:** Identify a Successful Code
 - Look for a 302 status code in the Intruder results, indicating a successful login.
 - Copy the successful request to Burp Repeater.

![Screenshot from 2024-11-23 11-44-22](https://github.com/user-attachments/assets/8c5b9329-18e0-4678-8f93-3d038967982e)

Step 7: Finalize the Exploit
 - Send the successful POST /login2 request from Repeater with:
 - verify: carlos
 - session: Valid session token.

![Screenshot from 2024-11-23 11-48-41](https://github.com/user-attachments/assets/2320b231-8976-494b-bb20-edcc2f2865ba)

**mfa-code**: The brute-forced MFA code.

Open the session in a new browser tab to confirm access to Carlos's account.

![Screenshot from 2024-11-23 11-43-58](https://github.com/user-attachments/assets/8404a556-e624-4b77-8061-50fb387248c9)

Step 8: Explanation of the Vulnerability
 - The application fails to securely enforce MFA, allowing brute-force attacks on the MFA code.
 - The logic flaw permits session token reuse after modifying the verify parameter, bypassing intended access restrictions.
 - The MFA code is vulnerable to brute-forcing due to its short length (4 digits) and lack of rate-limiting.

# **LAB:3**

# **Lab: 2FA bypass using a brute-force attack**

**AIM**- To solve the lab, brute-force the 2FA code and access Carlos's account page.

**Victim's credentials**: carlos:montoya

**Step 1**: Investigating the 2FA Process
First, I logged in as Carlos and observed the behavior of the 2FA verification process. If you enter an incorrect 2FA code twice, the application automatically logs you out. This means I needed to configure Burp Suite to handle the re-login process automatically before each request, so I could keep testing without manually logging back in every time.

**Step 2**: Configuring Session Handling in Burp Suite
To set up session handling:
 - In Burp, I opened the Settings dialog and navigated to the Sessions tab.
 - Under Session Handling Rules, I clicked Add to create a new session handling rule.

In the rule editor:
 - Under the Scope tab, I selected Include all URLs to ensure the rule applied to all requests.
 - Under the Details tab, I added a new action: Run a macro.

**Step 3:** Creating and Testing a Macro

For the macro:
I clicked Add in the Select macro section to open the Macro Recorder.

I selected the following three requests for the macro:
```
GET /login

POST /login

GET /login2
```
After saving the macro, I tested it using the Test macro button. The test confirmed that the final response showed the page asking for the 4-digit security code. This verified that the macro was working correctly.
![image](https://github.com/user-attachments/assets/007760d7-dd6c-4ca7-8ff5-3f59543f76a1)

After confirming the macro, I saved all settings and returned to the main Burp Suite window. Now, Burp would automatically re-log me in as Carlos whenever I sent a request, ensuring I didn’t get logged out during testing.

**Step 4**: Sending the Request to Intruder
 - Next, I sent the POST /login2 request to Burp Intruder. This is the request where the application verifies the 2FA code.
 - In Intruder, I added a payload position to the mfa-code parameter.
 - Under the Payloads tab, I selected the Numbers payload type.
 - I set the range to 0000–9999, ensuring all 4-digit combinations were tested.
 - I configured the step to 1 and ensured that the Minimum/Maximum integer digits were set to 4. This setup generated every possible 4-digit code as a payload.

**Step 5:** Managing Resources and Starting the Attack
 - In the Resource pool settings, I created a resource pool for this attack with the Maximum concurrent requests set to 1. This was to prevent the server from being overwhelmed with multiple requests at the same time.
 - I started the attack in Intruder. The tool cycled through all possible 4-digit codes, sending each one as the mfa-code parameter.

Step 6: Identifying the Successful Code

 - After some time, one of the requests returned a 302 status code, indicating a successful response.
 - I right-clicked on this request and selected Show response in browser.
 - Burp generated a URL, which I copied and loaded into the browser.

After logging in successfully, I clicked on My Account, which confirmed that the lab was solved.
![image](https://github.com/user-attachments/assets/2a342d22-7479-4774-a0f7-22ab2555e329)

### Key Learning Points:

Session Handling: Automating login workflows with macros in Burp Suite saves time and effort when dealing with repetitive logins during brute-force testing.

**Intruder Configuration**: Properly configuring payloads and resource pools ensures efficient attacks without overloading the server.

**2FA Bypass Vulnerability**: The lab demonstrated a weakness in the 2FA implementation, allowing brute-forcing of the 4-digit MFA code.
