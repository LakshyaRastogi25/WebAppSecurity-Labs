---
# Lab: 1 Reflected XSS into HTML context with nothing encoded
# **Write-Up: Reflected XSS in Search Functionality**  

### **Overview**  
This lab demonstrates a reflected Cross-Site Scripting (XSS) vulnerability in the search functionality of a web application. The input is reflected in the response without proper sanitization, allowing an attacker to inject and execute malicious scripts.  

### **Steps to Exploit**  

1. **Testing Input Reflection:**  
   - I entered a simple string `"Heyy"` in the search bar.  
   - The response reflected my input in the HTML page, confirming that user input is returned without encoding.  
![Screenshot from 2025-02-18 10-16-39](https://github.com/user-attachments/assets/6ecbeaed-e491-4d7e-bb8d-326e8871cbd9)

2. **Injecting a Basic XSS Payload:**  
   - To verify XSS, I injected the following payload in the search input:  
     ```html
     <script>alert(1)</script>
     ```
   - Upon submitting, the browser executed the JavaScript, displaying an alert box with `1`.  
![Screenshot from 2025-02-18 10-23-40](https://github.com/user-attachments/assets/d17799b3-1656-4fce-990c-d15b2a927cf4)

3. **Confirmation of Vulnerability:**  
   - Since the JavaScript executed successfully, the application is vulnerable to reflected XSS.  
![Screenshot from 2025-02-18 10-23-45](https://github.com/user-attachments/assets/90f5fbae-eab7-4188-aa3c-95a48de89809)

---
 

---
# Lab 2: 
# **Exploiting XSS Through Burp Intruder**

## **Step 1: Testing for Initial XSS Filtering**
To begin, we attempted to inject a standard XSS vector:  

```html
<img src=1 onerror=print()>
```
However, this payload was **blocked** by the application’s filtering mechanisms. Since our initial attempt failed, we need to **analyze which tags and attributes are allowed** by the application.  

---

## **Step 2: Identifying Allowed HTML Tags Using Burp Intruder**
1. **Open Burp's browser** and use the search function in the lab.  
2. **Send the resulting request to Burp Intruder** for further testing.  
3. In **Burp Intruder**, replace the value of the search term with:  

   ```html
   <>
   ```
4. Place the cursor **between the angle brackets** and click **Add §** to create a payload position.  
   - The value should now look like:  
     ```html
     <§§>
     ```
5. **Visit the XSS cheat sheet** and click **Copy tags to clipboard**.  
6. In the **Payloads** panel, under **Payload configuration**, click **Paste** to insert the list of tags into the payload list.  
7. Click **Start attack** to test which tags are allowed.  


---

## **Step 3: Injecting Attributes Into `<body>`**
Since `<body>` is allowed, we now need to determine **which attributes are accepted**.
![Screenshot from 2025-02-22 12-14-05](https://github.com/user-attachments/assets/ebcce42e-98bc-4fa2-b719-1a641a09edb4)

1. **Modify the Burp Intruder search term** and replace it with:  

   ```html
   <body%20=1>
   ```
2. **Place the cursor before the `=` character** and click **Add §** to create a payload position.  
   - The value should now look like:  
     ```html
     <body%20§§=1>
     ```
3. **Visit the XSS cheat sheet** and click **Copy events to clipboard**.  
4. In the **Payloads** panel, click **Clear** to remove previous payloads.  
5. Click **Paste** to insert the **list of attributes** into the payloads list.  
6. Click **Start attack** to test which event handlers are allowed.  
![Screenshot from 2025-02-22 00-06-06](https://github.com/user-attachments/assets/fb6f193d-fcff-4373-9d8f-6d3e83558135)

---

## **Step 4: Delivering the Exploit**
Now that we know the **`onresize` attribute works**, we will craft a final payload to **execute JavaScript on the victim's browser**.  

1. Go to the **exploit server** and paste the following payload:  

   ```html
   <iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
   ```
2. Replace **`YOUR-LAB-ID`** with the actual **Lab ID** for your target.  
3. Click **Store** and then **Deliver exploit to victim**.  

# Lab: 3 Reflected XSS with some SVG markup allowed
### **Write-Up: Exploiting XSS Using Burp Intruder**  

---

### **Step 1: Testing for Initial XSS Filtering**  

To begin, we attempted to inject a standard XSS payload:  

```html
<img src=1 onerror=alert(1)>
```
However, this payload **was blocked** by the application’s security mechanisms. Since this attempt failed, we need to analyze **which HTML tags and attributes are allowed** using Burp Intruder.  

---

### **Step 2: Identifying Allowed HTML Tags Using Burp Intruder**  

1. **Open Burp's browser** and use the search function in the lab.  
2. **Send the resulting request to Burp Intruder** for further testing.  
3. In the **request template**, replace the value of the search term with:  

   ```html
   <>
   ```
4. **Place the cursor between the angle brackets (`<>`)** and click **Add §** to create a payload position.  
   - The value should now be:  
     ```html
     <§§>
     ```
5. **Visit the XSS cheat sheet** and click **Copy tags to clipboard**.  
6. In **Burp Intruder**, in the **Payloads** side panel, click **Paste** to insert the list of tags into the payloads list.  
7. Click **Start attack** to test which tags are allowed.  

### **Results Analysis:**  
- Most payloads caused a **400 Bad Request** response, meaning they were blocked.  
- However, the following **tags resulted in a 200 OK response** (indicating they were allowed):  
  - `<svg>`  
  - `<animatetransform>`  
  - `<title>`  
  - `<image>`  
![Screenshot from 2025-02-22 12-35-11](https://github.com/user-attachments/assets/0914ac64-dd78-4981-b45d-01973c72f9c9)

Since `<svg>` and `<animatetransform>` were not blocked, we can attempt further exploitation using them.  

---

### **Step 3: Injecting Attributes Into `<animatetransform>`**  

Since `<animatetransform>` is allowed, we now need to determine **which attributes can execute JavaScript**.

1. **Modify the Burp Intruder search term** and replace it with:  

   ```html
   <svg><animatetransform%20=1>
   ```
2. **Place the cursor before the `=` character** and click **Add §** to create a payload position.  
   - The value should now be:  
     ```html
     <svg><animatetransform%20§§=1>
     ```
3. **Visit the XSS cheat sheet** and click **Copy events to clipboard**.  
4. In **Burp Intruder**, in the **Payloads** side panel, click **Clear** to remove previous payloads.  
5. Click **Paste** to insert the **list of attributes** into the payloads list.  
6. Click **Start attack** to test which event handlers are allowed.  

### **Results Analysis:**  
- Most attributes caused a **400 response**, meaning they were blocked.  
- However, the **`onbegin` attribute** resulted in a **200 OK** response, meaning it was accepted.  
![Screenshot from 2025-02-22 12-40-53](https://github.com/user-attachments/assets/6764e814-0650-478b-96b4-5175e0324d95)

This means we can execute JavaScript using:  

```html
<svg><animatetransform onbegin=alert(1)>
```

---

### **Step 4: Delivering the Exploit**  

Now that we know the **`onbegin` attribute works**, we will craft a final payload to **execute JavaScript when the animation starts**.  

1. **Visit the following URL in the browser** to confirm that `alert(1)` is executed:  

   ```html
   https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E
   ```
2. Replace **`YOUR-LAB-ID`** with the actual **Lab ID** for your target.  
3. When the page loads, the **onbegin event will trigger `alert(1)`**, confirming a successful XSS exploit.  
![Screenshot from 2025-02-22 12-44-55](https://github.com/user-attachments/assets/62247768-5dc2-410b-bc77-3aff8748b67e)
![Screenshot from 2025-02-22 12-45-05](https://github.com/user-attachments/assets/98d6c416-0f98-4dda-b9e4-9cb73a40d1b2)

---

### **How Encoding Works:**
You noticed that our payload:  

```html
<svg><animatetransform onbegin=alert(1)>
```
was **encoded into**:  

```
%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E
```

Let’s break this down:  

| **Character** | **Original** | **Encoded (URL Encoding)** |
|--------------|-------------|----------------------------|
| `"`          | `"`         | `%22`                     |
| `>`          | `>`         | `%3E`                     |
| `<`          | `<`         | `%3C`                     |
| `space`      | ` `         | `%20`                     |

**Explanation:**  
- The `"` (`%22`) at the start is used to **break out of an attribute value** if the application is injecting our input inside an attribute.  
- The `>` (`%3E`) ensures we **close any existing HTML tag** and start our `<svg>` tag.  
- `<svg>` and `<animatetransform>` execute normally after decoding.  
- `%20` is just the encoded space between `animatetransform` and `onbegin`.  

---

# **Lab 4 Write-Up: XSS in HTML Tag Attributes**  

### **Step 1: Identify the Vulnerability**  
- The lab's **search blog functionality** is vulnerable to **reflected XSS**.  
- **Angle brackets (`< >`) are encoded**, meaning we **cannot inject `<script>` tags** directly.  
- Our goal is to **inject an attribute** that triggers JavaScript execution.  

---

### **Step 2: Crafting the Payload**  
Since `<script>` tags are blocked, we use an **event handler** inside an HTML attribute.  

**Final Payload:**  
```html
" autofocus onfocus=alert(document.domain) x="
```

### **Why This Works?**  
- `"` → Closes the existing attribute.  
- `autofocus` → Automatically focuses on the element.  
- `onfocus=alert(document.domain)` → Triggers an alert when the element is focused.  
- `x="` → Prevents breaking the HTML structure.  

---

### **Step 3: Injecting the Payload**  
1. **Go to the search function of the blog.**  
2. **Enter the payload** in the search bar.  
3. **Submit the search query.**  

---

### **Step 4: Observing Execution**  
- The search field **automatically gains focus**, triggering the `onfocus` event.  
- The **alert box appears**, confirming **successful XSS execution**.  
![Screenshot from 2025-02-22 22-36-21](https://github.com/user-attachments/assets/357e6cab-02e2-4a51-bf24-9fd112b972f3)

---

### **Step 5: Lab Completion**  
- The JavaScript executed successfully.  
- The **lab is now solved!**  

---

# Lab: 5 Reflected XSS in canonical link tag

# **Lab Write-Up: Accesskey-Based XSS in the Comment Author's Website Field**  

### **Understanding the Vulnerability**  
This lab contains a **stored cross-site scripting (XSS) vulnerability** in the **comment functionality**. The issue occurs because the **Website** field in the comment form is reflected inside an `<a>` tag as the `href` attribute without proper sanitization.  

#### **Reflected HTML Code:**
```html
<a id="author" href="USER_INPUT">kyu btau</a>
```
Since **our input is directly placed inside the `href` attribute**, we can try **injecting additional attributes** using special encoding techniques.  

---

### **Crafting the Payload**
Since the `href` value is wrapped in double quotes (`"`), we need to **break out of it** safely and inject our own attributes.  
Using URL encoding, we crafted the following payload:  

**Final Payload (to enter in the Website field):**  
```
?%27accesskey=%27x%27onclick=%27alert(1)
```

---

### **How the Payload Works**
After submission, the input is reflected as:  
```html
<a id="author" href="?' accesskey='x' onclick='alert(1)'>kyu btau</a>
```
**`?`** → Ensures it’s treated as part of the URL.  
**`%27` (`'`)** → **Closes the `href` attribute safely** to prevent breaking the tag structure.  
**`accesskey='x'`** → Defines a keyboard shortcut (`Alt + Shift + X`) to activate the element.  
**`onclick='alert(1)'`** → Executes JavaScript when the access key is triggered.  

---

### **Steps to Exploit**
**Enter the payload** in the **Website** field when submitting a comment:  
```
?%27accesskey=%27x%27onclick=%27alert(1)
```
**Submit the comment.**  
**Inspect the rendered HTML** (`Ctrl + U`) to confirm that `accesskey` and `onclick` were injected.  
**Trigger the attack** by pressing:  
   ```
   Alt + Shift + X
   ```
   **On Ubuntu (Chromium), this activates the accesskey and executes `alert(1)`.**  
![Screenshot from 2025-02-23 00-37-53](https://github.com/user-attachments/assets/7957665b-4871-420c-bb3c-ae6383766c6e)

---

### **Expected Outcome**
 - The JavaScript `alert(1)` executes when the keyboard shortcut **`Alt + Shift + X`** is pressed.
 - Since this is a **stored XSS**, it **affects all users viewing the comment**.  
**Lab is solved!**  
![Screenshot from 2025-02-23 00-38-01](https://github.com/user-attachments/assets/3a12ef7f-a9a7-4005-aed5-e42a1d54f158)

---

# **Lab:6  Write-Up:Reflected XSS into a JavaScript string with angle brackets HTML encoded**  

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** where user input is inserted inside a JavaScript string. The vulnerable JavaScript code is:  

```html
<script>
    var searchTerms = 'USER_INPUT_HERE';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **user-controlled input** is placed inside a JavaScript variable (`searchTerms`).  
- The application **does not properly sanitize the input**, allowing us to **break out of the script and execute arbitrary JavaScript**.  

---

## **2. Crafting the Payload**  
To exploit this, we need to:  
1. **Break out of the JavaScript string**  
2. **End the `<script>` block**  
3. **Inject a new `<script>` tag** containing our XSS payload  

### **Final Payload:**  
```
"</script><script>alert(1)</script>"
```
### **How This Works:**  
- **`"</script>`** → Closes the existing `<script>` tag.  
- **`<script>alert(1)</script>`** → Injects a new `<script>` tag that executes `alert(1)`.  

After injection, the browser interprets the following **maliciously crafted HTML**:  
```html
<script>
    var searchTerms = "";
</script>
<script>alert(1)</script>
<script>
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **original JavaScript is terminated early**.  
- The **injected `<script>` tag runs immediately**, executing the `alert(1)`.  
- The **rest of the page loads normally** without errors.  

---

## **3. Steps to Exploit**  
1. **Locate the input field where `searchTerms` is reflected.**  
2. **Enter the following payload:**  
   ```
   "</script><script>alert(1)</script>"
   ```
3. **Submit the input.**  
4. **Observe that an alert box appears**, confirming XSS execution.  

![Screenshot from 2025-02-23 13-29-09](https://github.com/user-attachments/assets/0de0a422-c083-4660-98ae-4cde775207e5)

---

## **4. Expected Outcome**  
- **JavaScript execution is successfully achieved.**  
- **The alert function runs when the page loads.**  
- **Lab is solved.**  
![Screenshot from 2025-02-23 13-29-14](https://github.com/user-attachments/assets/55158b3f-1f91-4f08-97ce-7bbb1c853b56)


# **Lab 7 Write-Up: Exploiting JavaScript String to Inject XSS**

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** in a JavaScript context. The vulnerable code is as follows:

```html
<script>
    var searchTerms = 'USER_INPUT_HERE';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
The **`searchTerms`** variable is **directly injected into JavaScript** without proper sanitization or escaping. This creates an opportunity for an attacker to break out of the string and execute arbitrary JavaScript.  

---

## **2. Crafting the Exploit Payload**
The **goal** is to **break out** of the string (`'USER_INPUT_HERE'`), **terminate the current JavaScript statement**, and **inject JavaScript** that executes when the page is loaded.  

The successful payload is:  
```
'; alert(1); //
```

### **How the Payload Works:**
- **`'`** → Closes the string that is being assigned to `searchTerms`.  
- **`;`** → Ends the JavaScript statement.  
- **`alert(1);`** → Executes the JavaScript function `alert(1)`, which triggers an alert box.  
- **`//`** → Comments out the rest of the code to avoid syntax errors.  

### **Rendered JavaScript After Injection:**
```html
<script>
    var searchTerms = ''; alert(1); //';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
This **breaks out of the string** and **injects JavaScript** that executes immediately when the page is rendered.

---

## **3. Steps to Exploit the Vulnerability**
1. **Locate the input field** where `searchTerms` is reflected.  
2. **Enter the following payload in the input field:**
   ```
   '; alert(1); //
   ```
3. **Submit the form** containing the payload.  
4. **Observe the execution of the payload**—an alert box should appear.  
![Screenshot from 2025-02-23 13-29-09](https://github.com/user-attachments/assets/175a927a-c17f-440d-bf21-c63933d78683)

---

## **4. Expected Outcome**
- The payload successfully **breaks out of the string** and **executes the `alert(1)`** JavaScript function.  
- **The alert box appears**, confirming that XSS has been successfully triggered.  
- **The lab is solved.**
![Screenshot from 2025-02-23 13-29-14](https://github.com/user-attachments/assets/6116217a-1b23-4c64-9dff-5a3f5623be13)


# **Lab 8 Write-Up: Reflected XSS into a JavaScript string with single quote and backslash escaped**  

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** inside a JavaScript string. The vulnerable code looks like this:  

```html
<script>
   var searchTerms = '\';&lt;script&gt;alert(1)&lt;/script&gt;';
   document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **user-controlled input** is placed inside a **JavaScript string enclosed in single quotes (`'`).**  
- The application **escapes single quotes (`'`) by adding a backslash (`\`) before them**, making injection more difficult.  
- However, **the backslash (`\`) itself is not escaped**, allowing an attacker to **neutralize the escaping mechanism** and break out of the string.  

---

## **2. Identifying the Vulnerability**
When testing the application, I noticed that:
- Entering a single quote (`'`) resulted in `\'`, meaning **the application escapes single quotes (`'`) with a backslash (`\`)**.  
- However, entering a **backslash (`\`) itself** did **not** get escaped, which meant I could **bypass the escaping by injecting my own backslash (`\`).**  

---

## **3. Crafting the Exploit Payload**  
The goal was to:
1. **Break out of the JavaScript string.**  
2. **Inject a malicious JavaScript payload (`alert(document.domain)`).**  
3. **Ensure the script remains valid to avoid syntax errors.**  

### **Final Payload:**
```
\';alert(document.domain)//
```

---

### **4. How the Payload Works**
**What Happens When the Application Processes This Input?**  
Since **single quotes (`'`) are escaped** but **backslashes (`\`) are not**, injecting `\';alert(document.domain)//` results in:

```
\\';alert(document.domain)//
```
Breaking it down:
1. **First backslash (`\`) neutralizes the second backslash (`\`)**, making JavaScript interpret it as a normal character.  
2. **The single quote (`'`) now terminates the original string**, breaking out of the JavaScript string.  
3. **`alert(document.domain);` executes immediately.**  
4. **`//` comments out the rest of the line** to prevent syntax errors.  

**Final Rendered JavaScript:**
```js
var searchTerms = ''; alert(document.domain)//';
document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
```
- The **JavaScript string is closed prematurely.**  
- **`alert(document.domain)` executes immediately.**  
- **Everything after `//` is ignored**, preventing errors.  

---

## **5. Steps to Exploit the Vulnerability**
1. **Locate the input field** where `searchTerms` is reflected.  
2. **Enter the following payload in the input field:**
   ```
   \';alert(document.domain)//
   ```
3. **Submit the input.**  
4. **Observe that an alert box appears**, confirming that XSS has been successfully executed.  
![Screenshot from 2025-02-23 11-55-37](https://github.com/user-attachments/assets/fa20356e-2c11-403c-ba52-827e18dfd7da)

---

## **6. Expected Outcome**
- The **payload successfully breaks out of the JavaScript string** and **executes `alert(document.domain)`**.  
- The **alert box appears**, proving that XSS execution was achieved.  
- **The lab is solved.**  
![Screenshot from 2025-02-23 12-04-32](https://github.com/user-attachments/assets/83791c5e-23f7-48f6-bf6f-b923f30c10d0)

---

# **Lab 9 Write-Up: Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped**

## **1. Introduction**
This lab demonstrates how **Cross-Site Scripting (XSS)** vulnerabilities can arise when user input is reflected inside a **JavaScript template literal**. The technique involves intercepting a request using **Burp Suite** and manipulating the reflected input to inject JavaScript code that gets executed inside the template literal.

### **Goal:**
- Intercept a search request using Burp Suite.
- Modify the reflected input inside the **JavaScript template literal** to execute a payload (`alert(1)`).
- Verify that the technique triggers an alert when the page is loaded.

---

## **2. Step-by-Step Explanation**

### **Step 1: Submit a Random Alphanumeric String in the Search Box**
Start by submitting a random alphanumeric string (e.g., `abc123`) in the search box of the vulnerable web application. This string will be reflected back in the server's response.

### **Step 2: Intercept the Request in Burp Suite**
- Open **Burp Suite** and enable **Intercept** in the **Proxy** tab.
- Submit the random string through the search form.
- **Burp Suite will intercept the HTTP request**. Right-click on the intercepted request and choose **Send to Repeater**.

### **Step 3: Analyze the Response in Burp Repeater**
- In **Burp Repeater**, you’ll see the HTTP request and response.
- Observe that the **random string** you entered is reflected inside a **JavaScript template literal** in the response body. For example:
  ```js
  var input = `abc123`;
  ```
  This means the application is directly embedding user input into a JavaScript template literal without properly sanitizing or escaping it.

### **Step 4: Inject XSS Payload into the Template String**
- Replace the reflected input (`abc123`) with the following XSS payload:
  ```js
  ${alert(1)}
  ```
- The payload uses the **template literal's embedded expression** syntax (`${}`) to inject the `alert(1)` function. The expression inside `${}` is evaluated, which results in JavaScript code execution.

#### **Final Result in Repeater:**
The response now looks like this:
```js
var input = `${alert(1)}`;
```

When the page is loaded, the `alert(1)` will execute, causing a pop-up to appear.

### **Step 5: Test the Exploit**
- In Burp Repeater, click **Send** to forward the modified request to the browser.
- **Right-click on the page and select "Copy URL"** to get the full URL that triggered the request.
- Paste the URL in your browser's address bar and load the page.

### **Step 6: Verify the XSS Exploit**
- When you load the page with the modified URL, **the JavaScript alert box** should appear with the message `1`, confirming that the **XSS payload** was successfully executed.

---

## **3. How It Works**

### **JavaScript Template Literals and XSS**
- **Template literals** in JavaScript allow you to embed expressions inside a string using `${}` syntax. The expression inside `${}` is evaluated as JavaScript code when the template literal is processed.
- If user input is reflected inside a template literal **without proper sanitization**, an attacker can inject their own JavaScript code inside `${}`. This allows the attacker to execute arbitrary JavaScript.

In this case, by injecting `${alert(1)}`, the attacker causes the `alert(1)` function to be executed when the page is rendered.

### **Why This Happens**
- The application reflects user input directly inside a **JavaScript template literal** without encoding or sanitizing the input. This makes it possible to inject executable JavaScript.
- Template literals are **dynamically evaluated**, and **any code inside `${}`** will be executed as JavaScript.

---

## **4. Mitigating XSS in Template Literals**
To prevent this type of attack, web applications should:
1. **Sanitize user input** before inserting it into JavaScript code. This can be done by:
   - **Escaping special characters** like `<`, `>`, `"`, `'`, and `${}`.
   - **Validating and filtering user input** to block dangerous content.
   
2. **Avoid embedding user input directly into JavaScript code**. Use **server-side sanitization** to process user input safely.

3. **Implement Content Security Policy (CSP)** to prevent inline script execution and block malicious JavaScript from running.

---

## **5. Conclusion**
- In this lab, we exploited a **JavaScript template literal** by injecting an **XSS payload** (`${alert(1)}`) into reflected user input.
- The **lack of input sanitization** allowed the injected payload to execute when the template literal was processed, causing a JavaScript alert box to appear.
- Proper input sanitization, escaping, and a strong **Content Security Policy (CSP)** are essential to prevent this type of vulnerability.

This lab successfully demonstrates how **XSS can be exploited in JavaScript template literals** when input is reflected without proper sanitization.
