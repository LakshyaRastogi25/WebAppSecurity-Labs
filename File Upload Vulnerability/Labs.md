**Lab: Remote code execution via web shell upload**

**Aim** - To solve the lab, upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret

Your credentials - **wiener:peter**

**1. Logging In and Observing the Avatar Upload Functionality**

While proxying traffic through Burp Suite, I logged into my account on the target website.

On the account page, I noticed an option to upload an avatar image.

I uploaded a random image (e.g., test.jpg) and observed that a preview of the avatar appeared on my account page.

**2. Identifying the Avatar Fetch Request**

In Burp Suite, I navigated to Proxy > HTTP history to examine the traffic.

I used the filter bar to filter requests by MIME type:

Opened the filter window.

Enabled the Images checkbox.

Applied the changes.

In the filtered HTTP history, I found a GET request that fetched the uploaded avatar using this pattern:

GET /files/avatars/<YOUR-IMAGE>

I sent this request to Burp Repeater for further testing.

**3. Preparing the Exploit File**

On my local system, I created a file named exploit.php containing the following malicious PHP script:

<?php echo file_get_contents('/home/carlos/secret'); ?>

This script attempts to read the contents of Carlos's secret file located at /home/carlos/secret.

**4. Uploading the Malicious PHP File**

I returned to the avatar upload functionality on the website and uploaded my exploit.php file as the avatar.

The server responded with a confirmation message indicating that the file was successfully uploaded.

**5. Executing the Exploit**

In Burp Repeater, I modified the path in the previously captured GET request to point to my malicious PHP file:

GET /files/avatars/exploit.php HTTP/1.1

I sent the request. The server executed the PHP script and returned its output, which contained Carlos's secret.

**6. Submitting the Secret**

I copied Carlos's secret from the response and submitted it to complete the lab.

**Key Observations**

The server did not properly validate the file type during the upload, allowing me to upload a PHP file.

When the uploaded PHP file was accessed, the server executed it instead of treating it as a regular file.

This vulnerability is an example of Unrestricted File Upload, which can lead to Remote Code Execution (RCE) if exploited.

**Lab: Web shell upload via Content-Type restriction bypass**

**Step 1: Analyze the Avatar Upload Functionality**

Log in to your account on the target application.

Navigate to the avatar upload feature and upload an arbitrary image (e.g., image.jpg) as your avatar.

After uploading, return to your account page. Notice that the uploaded image is displayed as a preview.

**Step 2: Intercept the Image Fetch Request**

Open Burp Suite and go to Proxy > HTTP history.

Locate the GET request used to fetch your avatar image at the path /files/avatars/<YOUR-IMAGE>.

Send this request to Burp Repeater for later use.

**Step 3: Create the Exploit Script**

On your local machine, create a PHP script named exploit.php with the following contents:

**<?php echo file_get_contents('/home/carlos/secret'); ?>**

This script reads the sensitive file /home/carlos/secret and outputs its contents.

**Step 4: Attempt to Upload the Exploit Script**

Use the avatar upload functionality to attempt uploading exploit.php as your avatar.

Observe that the server rejects the upload, stating that only files with the MIME type image/jpeg or image/png are allowed.

**Step 5: Modify the File Upload Request**

Go to Proxy > HTTP history in Burp Suite.

Find the POST /my-account/avatar request responsible for submitting the avatar upload.

Send this request to Burp Repeater.

In Burp Repeater, locate the section in the request body that specifies the Content-Type for the uploaded file. Change it from:

Content-Type: application/x-php
to:
Content-Type: image/jpeg

Send the modified request.

Observe that the server responds, confirming the file upload was successful.

**Step 6: Execute the Malicious Script**

Switch to the GET /files/avatars/<YOUR-IMAGE> request in Burp Repeater.

Replace the file name in the path with exploit.php:

GET /files/avatars/exploit.php HTTP/1.1

Send the request.

Observe that the server executes the script and returns the contents of Carlos's secret file in the response.

**Step 7: Submit the Secret**

Copy the secret returned in the response.

Submit it to the lab to complete the challenge.

Key Takeaways

Weak File Validation: The server only checks the Content-Type header for file validation, which can easily be manipulated.

Insecure File Uploads: Allowing execution of uploaded files without proper validation leads to vulnerabilities like Remote Code Execution (RCE).

Best Practices:

Validate uploaded files based on their actual content (e.g., checking file headers or magic bytes).

Store uploaded files in non-executable directories to prevent them from being executed on the server.

**Lab: Web shell upload via path traversal**

**Step 1: Analyze the Avatar Upload Functionality**

Log in to your account on the target application.

Navigate to the avatar upload feature and upload an arbitrary image (e.g., image.jpg) as your avatar.

After uploading, return to your account page. Notice that the uploaded image is displayed as a preview.

**Step 2: Intercept the Image Fetch Request**

Open Burp Suite and go to Proxy > HTTP history.

Locate the GET request used to fetch your avatar image at the path /files/avatars/<YOUR-IMAGE>.

Send this request to Burp Repeater for later use.

**Step 3: Create the Exploit Script**

On your local machine, create a PHP script named exploit.php with the following contents:

**<?php echo file_get_contents('/home/carlos/secret'); ?>**

This script reads the sensitive file /home/carlos/secret and outputs its contents.

**Step 4: Attempt to Upload the Exploit Script**

Use the avatar upload functionality to attempt uploading exploit.php as your avatar.

Observe that the server rejects the upload, stating that only files with the MIME type image/jpeg or image/png are allowed.

**Step 5: Modify the File Upload Request**

Go to Proxy > HTTP history in Burp Suite.

Find the POST /my-account/avatar request responsible for submitting the avatar upload.

Send this request to Burp Repeater.

In Burp Repeater, locate the section in the request body that specifies the Content-Type for the uploaded file. Change it from:

Content-Type: application/x-php
**to:**
Content-Type: image/jpeg

Send the modified request.

Observe that the server responds, confirming the file upload was successful.

**Step 6: Execute the Malicious Script**

Switch to the GET /files/avatars/<YOUR-IMAGE> request in Burp Repeater.

Replace the file name in the path with exploit.php:

GET /files/avatars/exploit.php HTTP/1.1

Send the request.

Observe that the server executes the script and returns the contents of Carlos's secret file in the response.

**Step 7: Submit the Secret**

Copy the secret returned in the response.

Submit it to the lab to complete the challenge.
"**Btb8vzFNtwLrmvb1FFAe7uybK8EVS2T***"

**Key Takeaways**

Weak File Validation: The server only checks the Content-Type header for file validation, which can easily be manipulated.

Insecure File Uploads: Allowing execution of uploaded files without proper validation leads to vulnerabilities like Remote Code Execution (RCE).

Best Practices:

Validate uploaded files based on their actual content (e.g., checking file headers or magic bytes).

Store uploaded files in non-executable directories to prevent them from being executed on the server.

Step 1: Uploading an Image as Avatar
Log in to the web application and upload an image as your avatar.

Navigate to your account page and observe that the image is fetched using a GET request to:

bash
Copy
Edit
GET /files/avatars/<YOUR-IMAGE>
Send this request to Burp Suite's Repeater for further analysis.

Step 2: Preparing the PHP Exploit
Create a malicious PHP script (exploit.php) with the following payload to read Carlos's secret file:

php
Copy
Edit
<?php echo file_get_contents('/home/carlos/secret'); ?>
Attempt to upload the PHP file as an avatar, but the server rejects the request because it does not allow .php extensions.

Step 3: Identifying Server Type
In Burp Suite, find the POST /my-account/avatar request in the Proxy > HTTP history tab.
Observe the server response headers, which indicate that the application is running on an Apache server.
Step 4: Uploading a Malicious .htaccess File
Since Apache allows per-directory configuration using .htaccess files, we can leverage this feature to override the file execution settings.

Modify the upload request as follows:

Change the filename from exploit.php to .htaccess.
Set the Content-Type to text/plain (to prevent rejection by the server).
Replace the file content with the following Apache directive:
apache
Copy
Edit
AddType application/x-httpd-php .l33t
This directive maps files with the .l33t extension to be executed as PHP scripts by the server.

Send the modified upload request and verify that the .htaccess file is successfully uploaded.

Step 5: Uploading the PHP Payload with a Different Extension
Return to the original avatar upload request in Burp Repeater.
Modify the filename parameter from exploit.php to exploit.l33t (leveraging the previously uploaded .htaccess configuration).
Send the request and confirm that the upload succeeds.
Step 6: Executing the PHP Exploit
In Burp Repeater, return to the GET /files/avatars/<YOUR-IMAGE> request.

Replace the image filename with exploit.l33t and send the request:

bash
Copy
Edit
GET /files/avatars/exploit.l33t
The server processes the .l33t file as PHP (due to the .htaccess override), and Carlos's secret is displayed in the response.

Submit the secret to solve the lab.

Explanation of Apache Configuration Files and .htaccess
1. What is .htaccess?
.htaccess is a configuration file used by Apache web servers to override settings on a per-directory basis.
It allows web administrators to modify configurations without changing the global Apache configuration (apache2.conf or httpd.conf).
Common uses include:
URL rewriting (mod_rewrite)
Access control (password protection)
Custom error pages
File MIME type mappings (exploited in this attack)
2. How the Attack Works
Default Server Behavior: By default, Apache servers only execute files with predefined extensions (e.g., .php) and serve others as static content.
Abusing .htaccess: By uploading a custom .htaccess file, attackers can redefine which file extensions should be treated as PHP scripts.
The AddType Directive:
AddType application/x-httpd-php .l33t tells Apache to treat .l33t files as PHP scripts.
When the attacker uploads and accesses exploit.l33t, the server processes it as PHP.
3. Why This Works
Apache applies .htaccess configurations dynamically for each directory where it's placed.
The web application may lack proper validation and sanitization, allowing attackers to:
Upload unexpected file types (e.g., .htaccess).
Bypass extension filters using alternative mapped extensions (.l33t).
Developers may overlook the risks of directory-specific configurations.
4. Prevention Measures
To prevent such attacks, web developers should:

Restrict file upload types securely:

Use a whitelist of allowed file extensions.
Validate MIME types properly on both client and server sides.
Disable .htaccess overrides:

In Apache's main configuration (apache2.conf), set:

apache
Copy
Edit
AllowOverride None
Set strict directory permissions:

Ensure the web application cannot write to sensitive directories.
Monitor for suspicious uploads:

Regularly scan uploaded files for potentially malicious content.
