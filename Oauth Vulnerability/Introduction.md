# **What is OAuth?**

**OAuth** is a commonly used authorization framework that enables websites and web applications to request limited access to a user's account on another application. Crucially, OAuth allows the user to grant this access without exposing their login credentials to the requesting application. This means users can fine-tune which data they want to share rather than having to hand over full control of their account to a third party.

The basic OAuth process is widely used to integrate third-party functionality that requires access to certain data from a user's account. For example, an application might use OAuth to request access to your email contacts list so that it can suggest people to connect with. However, the same mechanism is also used to provide third-party authentication services, allowing users to log in with an account that they have with a different website.

**Main Components** :-
 - **Client application** - The website or web application that wants to access the user's data.
 - **Resource owner** - The user whose data the client application wants to access.
 - **OAuth service provider** - The website or application that controls the user's data and access to it. They support OAuth by providing an API for interacting with both an authorization server and a resource server.

### **OAuth grant types :-**

 - **a) Implicit Flow**-

 - **Purpose**: Designed for single-page applications (SPAs) where the client (browser) cannot securely store a client secret.

 - **Process**:
   - The user logs in and grants authorization.

   - The access token is directly returned to the browser via the redirect URI.

 - **Key Points**:
  - No authorization code step.
  - Tokens are exposed in the browser URL fragment (less secure).
  - No refresh tokens (tokens expire quickly to minimize risk)

 - **b) Authorization Code Flow**

  - **Purpose:** Used for server-side applications that can securely store a client secret.
  - **Process:**
   - The user logs in and grants authorization.
   - The authorization server issues an authorization code to the client.
   - The client exchanges the authorization code for an access token (and optionally a refresh token) by authenticating itself with the client secret.

 - **Key Points:**
  - More secure: Tokens are not exposed to the browser.
  - Requires an extra step (code exchange).

 - **c) Proof Key for Code Exchange (PKCE)**
  - **PKCE** is an extension of the Authorization Code Flow, designed to prevent authorization code interception attacks.
  - It is particularly useful for public clients (e.g., mobile apps, SPAs) that cannot store a client secret securely.

 - **Major components of grant types** - 

  - **client_id**

Mandatory parameter containing the unique identifier of the client application. This value is generated when the client application registers with the OAuth service.

  - **redirect_uri**

The URI to which the user's browser should be redirected when sending the authorization code to the client application. This is also known as the "callback URI" or "callback endpoint". Many OAuth attacks are based on exploiting flaws in the validation of this parameter.

  - **response_type**

Determines which kind of response the client application is expecting and, therefore, which flow it wants to initiate. For the authorization code grant type, the value should be code.

  - **scope**

Used to specify which subset of the user's data the client application wants to access. Note that these may be custom scopes set by the OAuth provider or standardized scopes defined by the OpenID Connect specification. We'll cover OpenID Connect in more detail later.

  - **state**

Stores a unique, unguessable value that is tied to the current session on the client application. The OAuth service should return this exact value in the response, along with the authorization code. This parameter serves as a form of CSRF token for the client application by making sure that the request to its /callback endpoint is from the same person who initiated the OAuth flow.

# **Oauth Authentication -** 

## **OpenID Connect**
### **What is OpenID Connect (OIDC)?**

OpenID Connect (OIDC) is a **simple identity layer** built on top of the **OAuth 2.0 protocol**. It allows applications (referred to as "clients") to verify a user’s identity based on the authentication performed by an **Authorization Server** and obtain basic profile information about the user in an interoperable and REST-like manner.

OIDC is designed to address **authentication** while OAuth 2.0 primarily handles **authorization**. Together, they ensure secure, user-friendly login experiences for modern applications.

---

### **Key Concepts**

#### **1. Authentication vs. Authorization**
- **Authentication**: Proves **who** a user is (identity verification).
- **Authorization**: Determines **what** a user can do (permissions).

OIDC extends OAuth 2.0 by adding an **authentication** mechanism, which makes it a complete solution for logging users into applications.

#### **2. Tokens in OIDC**
OIDC uses tokens to transmit information securely:
- **Access Token**: Used for **authorizing access** to resources (e.g., APIs).
- **ID Token**: A **JWT (JSON Web Token)** that contains information about the authenticated user (e.g., name, email, and user ID).
- **Refresh Token**: Used to get new access tokens without requiring the user to log in again.

#### **3. Identity Provider (IdP)**
The **IdP** (Authorization Server) is a trusted service that handles user authentication and issues tokens. Examples include:
- Google
- Facebook
- Microsoft
- Custom IdPs (e.g., Auth0)

---

### **How OpenID Connect Works**

OIDC works as a **3-party system**:
1. **End-user (Resource Owner)**: The user who wants to log in.
2. **Client (Relying Party)**: The application needing the user’s identity.
3. **Authorization Server (Identity Provider)**: The server that authenticates the user and issues tokens.

---

### **OIDC Flow (Step-by-Step)**

1. **User Tries to Access the Client App**
   - The user visits a website or app that supports OIDC.

2. **Redirection to the Authorization Server**
   - The client app redirects the user to the IdP’s login page (e.g., Google login) with a specific **request** containing:
     - Client ID
     - Redirect URI
     - Scope (`openid`, `profile`, `email`, etc.)
     - Response type (e.g., `code` for Authorization Code Flow)

3. **User Authenticates**
   - The user enters their credentials (e.g., username/password) on the IdP's login page.
   - The IdP authenticates the user.

4. **IdP Issues an Authorization Code**
   - If successful, the IdP redirects the user back to the client app’s redirect URI with an **authorization code**.

5. **Client Exchanges Code for Tokens**
   - The client app sends the authorization code to the IdP’s **token endpoint**.
   - The IdP verifies the code and responds with:
     - **ID Token** (contains user identity info like email or name)
     - **Access Token** (used to call APIs)
     - Optionally, a **Refresh Token**.

6. **Access Resources**
   - The client app uses the access token to interact with APIs.
   - The app can also use the ID token to display the user's profile or store their identity securely.

---

### **Benefits of OpenID Connect**

1. **User-Friendly**  
   - Simplifies the login experience (e.g., "Login with Google").
   - Reduces the need for users to remember multiple passwords.

2. **Interoperability**  
   - Standardized protocol ensures it works across various platforms and applications.

3. **Security**  
   - Uses secure tokens (JWT) to transmit user data.
   - Supports mechanisms like **PKCE** to prevent attacks (e.g., authorization code interception).

4. **Extensibility**  
   - Scopes allow flexibility. For example:
     - `openid`: Basic identity information.
     - `profile`: Name, profile picture, etc.
     - `email`: User's email address.

---

### **ID Token Structure**

The **ID Token** is a **JWT** (JSON Web Token) and contains 3 parts:
1. **Header**  
   - Specifies the signing algorithm (e.g., RS256).

2. **Payload**  
   - Contains claims (user information), such as:
     - `sub`: User ID.
     - `email`: User email address.
     - `name`: User's full name.
     - `iss`: Issuer (the IdP).
     - `aud`: Audience (the client app).

3. **Signature**  
   - Ensures the token hasn't been tampered with.

Example Payload:
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "email": "john.doe@example.com",
  "iss": "https://accounts.google.com",
  "aud": "client-id.apps.googleusercontent.com"
}
```

---

### **Common OIDC Flows**

1. **Authorization Code Flow (Recommended for Web Apps)**  
   - Secure flow for server-side applications.
   - Tokens are exchanged server-to-server, reducing exposure to attackers.

2. **Implicit Flow**  
   - Simplified but less secure.
   - Used by single-page applications (SPAs).
   - Tokens are returned directly in the browser.

3. **Hybrid Flow**  
   - Combines aspects of both Authorization Code and Implicit flows.
   - Used in scenarios requiring both client-side and server-side interactions.

4. **Device Code Flow**  
   - For devices with no browser or limited input (e.g., smart TVs).

---

### **Real-World Example: "Login with Google"**

1. A user clicks "Login with Google" on a website.
2. The user is redirected to Google’s login page (Authorization Server).
3. After logging in, Google authenticates the user and sends an authorization code back to the website.
4. The website exchanges the code for an ID token and access token.
5. The website uses the ID token to display the user's profile information (e.g., name, email).

---

### **OIDC Use Cases**

- Single Sign-On (SSO) for applications.
- Federated login using third-party IdPs (e.g., Google, Facebook).
- User authentication in mobile and web apps.
- API security with secure identity verification.

---

